<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AI Expression Detector - Ensemble Pro</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.2.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@vladmandic/face-api@1.7.13/dist/face-api.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/TextPlugin.min.js"></script>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap");

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      :root {
        --primary-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        --secondary-gradient: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        --accent-gradient: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        --success-gradient: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
        --glass-bg: rgba(255, 255, 255, 0.1);
        --glass-border: rgba(255, 255, 255, 0.2);
        --text-primary: #ffffff;
        --text-secondary: rgba(255, 255, 255, 0.8);
        --shadow-light: 0 8px 32px rgba(0, 0, 0, 0.1);
        --shadow-medium: 0 15px 40px rgba(0, 0, 0, 0.2);
        --shadow-heavy: 0 20px 60px rgba(0, 0, 0, 0.3);
      }

      body {
        font-family: "Inter", sans-serif;
        background: var(--primary-gradient);
        min-height: 100vh;
        overflow-x: hidden;
        position: relative;
      }

      body::before {
        content: "";
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(
            circle at 20% 20%,
            rgba(120, 119, 198, 0.3) 0%,
            transparent 50%
          ),
          radial-gradient(
            circle at 80% 80%,
            rgba(255, 118, 117, 0.3) 0%,
            transparent 50%
          ),
          radial-gradient(
            circle at 40% 40%,
            rgba(79, 172, 254, 0.2) 0%,
            transparent 50%
          );
        pointer-events: none;
        z-index: -1;
      }

      .floating-elements {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: -1;
      }

      .floating-shape {
        position: absolute;
        border-radius: 50%;
        background: var(--accent-gradient);
        opacity: 0.1;
        animation: float 6s ease-in-out infinite;
      }

      .floating-shape:nth-child(1) {
        width: 80px;
        height: 80px;
        top: 20%;
        left: 10%;
        animation-delay: 0s;
      }

      .floating-shape:nth-child(2) {
        width: 60px;
        height: 60px;
        top: 70%;
        left: 80%;
        animation-delay: 2s;
      }

      .floating-shape:nth-child(3) {
        width: 100px;
        height: 100px;
        top: 40%;
        left: 70%;
        animation-delay: 4s;
      }

      @keyframes float {
        0%,
        100% {
          transform: translateY(0px) rotate(0deg);
        }
        50% {
          transform: translateY(-20px) rotate(180deg);
        }
      }

      .container {
        max-width: 1400px;
        width: 100%;
        margin: 0 auto;
        padding: 20px;
        position: relative;
      }

      .hero-section {
        text-align: center;
        padding: 60px 0;
        opacity: 0;
        transform: translateY(50px);
      }

      .hero-title {
        font-size: 4rem;
        font-weight: 700;
        background: linear-gradient(135deg, #ffffff, #f0f0f0);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        margin-bottom: 20px;
        line-height: 1.2;
      }

      .hero-subtitle {
        font-size: 1.3rem;
        color: var(--text-secondary);
        margin-bottom: 40px;
        font-weight: 400;
      }

      .tech-badge {
        display: inline-block;
        background: var(--glass-bg);
        backdrop-filter: blur(20px);
        -webkit-backdrop-filter: blur(20px);
        border: 1px solid var(--glass-border);
        border-radius: 50px;
        padding: 12px 24px;
        color: var(--text-primary);
        font-weight: 600;
        font-size: 0.9rem;
        margin: 0 10px 20px 0;
        box-shadow: var(--shadow-light);
        transform: scale(0);
      }

      .status-container {
        margin: 40px 0;
        opacity: 0;
        transform: translateY(30px);
      }

      .status {
        background: var(--glass-bg);
        backdrop-filter: blur(20px);
        -webkit-backdrop-filter: blur(20px);
        border: 1px solid var(--glass-border);
        border-radius: 20px;
        padding: 20px 30px;
        color: var(--text-primary);
        font-size: 1.1rem;
        font-weight: 500;
        box-shadow: var(--shadow-medium);
        text-align: center;
        position: relative;
        overflow: hidden;
      }

      .status::before {
        content: "";
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          90deg,
          transparent,
          rgba(255, 255, 255, 0.1),
          transparent
        );
        transition: left 1s ease;
      }

      .status.loading::before {
        left: 100%;
      }

      .upload-section {
        background: var(--glass-bg);
        backdrop-filter: blur(20px);
        -webkit-backdrop-filter: blur(20px);
        border: 1px solid var(--glass-border);
        border-radius: 30px;
        padding: 40px;
        margin: 40px 0;
        box-shadow: var(--shadow-medium);
        opacity: 0;
        transform: translateY(50px);
        transition: all 0.3s ease;
      }

      .upload-section:hover {
        transform: translateY(-5px);
        box-shadow: var(--shadow-heavy);
      }

      .drop-zone {
        border: 2px dashed var(--glass-border);
        border-radius: 20px;
        padding: 60px 40px;
        text-align: center;
        cursor: pointer;
        transition: all 0.3s ease;
        background: rgba(255, 255, 255, 0.05);
        position: relative;
        overflow: hidden;
      }

      .drop-zone::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: var(--accent-gradient);
        opacity: 0;
        transition: opacity 0.3s ease;
      }

      .drop-zone:hover::before,
      .drop-zone.drag-over::before {
        opacity: 0.1;
      }

      .drop-zone:hover,
      .drop-zone.drag-over {
        border-color: #4facfe;
        transform: scale(1.02);
      }

      .drop-zone-content {
        position: relative;
        z-index: 1;
      }

      .drop-zone-icon {
        font-size: 4rem;
        margin-bottom: 20px;
        opacity: 0;
        transform: scale(0);
      }

      .drop-zone-text {
        font-size: 1.2rem;
        color: var(--text-primary);
        margin-bottom: 10px;
        font-weight: 500;
      }

      .drop-zone-subtext {
        font-size: 0.9rem;
        color: var(--text-secondary);
      }

      .upload-options {
        display: flex;
        gap: 20px;
        justify-content: center;
        margin-top: 30px;
        flex-wrap: wrap;
      }

      .upload-button {
        padding: 15px 30px;
        border: none;
        border-radius: 25px;
        background: var(--secondary-gradient);
        color: white;
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: var(--shadow-light);
        display: flex;
        align-items: center;
        gap: 10px;
        position: relative;
        overflow: hidden;
        transform: translateY(20px);
        opacity: 0;
      }

      .upload-button::before {
        content: "";
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          90deg,
          transparent,
          rgba(255, 255, 255, 0.2),
          transparent
        );
        transition: left 0.5s ease;
      }

      .upload-button:hover::before {
        left: 100%;
      }

      .upload-button:hover {
        transform: translateY(-3px);
        box-shadow: var(--shadow-medium);
      }

      .upload-button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
      }

      .file-input {
        display: none;
      }

      .camera-section {
        display: none;
        margin-top: 30px;
        opacity: 0;
        transform: translateY(30px);
      }

      .camera-container {
        position: relative;
        margin-bottom: 20px;
        border-radius: 20px;
        overflow: hidden;
        box-shadow: var(--shadow-medium);
      }

      #videoElement {
        width: 100%;
        max-width: 500px;
        height: 375px;
        border-radius: 20px;
        transform: scaleX(-1);
        object-fit: cover;
      }

      .camera-controls {
        display: flex;
        gap: 15px;
        justify-content: center;
        margin-top: 20px;
      }

      .image-container {
        position: relative;
        background: var(--glass-bg);
        backdrop-filter: blur(20px);
        -webkit-backdrop-filter: blur(20px);
        border: 1px solid var(--glass-border);
        border-radius: 30px;
        padding: 30px;
        margin: 40px 0;
        box-shadow: var(--shadow-medium);
        display: none;
        opacity: 0;
        transform: translateY(50px);
      }

      #imageDisplay {
        width: 100%;
        max-width: 600px;
        max-height: 600px;
        border-radius: 20px;
        box-shadow: var(--shadow-medium);
        display: block;
        margin: 0 auto;
      }

      .canvas-overlay {
        position: absolute;
        top: 30px;
        left: 30px;
        pointer-events: none;
        border-radius: 20px;
      }

      .analyze-button {
        padding: 18px 40px;
        border: none;
        border-radius: 30px;
        background: var(--success-gradient);
        color: #333;
        font-size: 1.1rem;
        font-weight: 700;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: var(--shadow-light);
        margin-top: 30px;
        display: block;
        margin-left: auto;
        margin-right: auto;
        position: relative;
        overflow: hidden;
        transform: scale(0);
      }

      .analyze-button::before {
        content: "";
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          90deg,
          transparent,
          rgba(255, 255, 255, 0.3),
          transparent
        );
        transition: left 0.5s ease;
      }

      .analyze-button:hover::before {
        left: 100%;
      }

      .analyze-button:hover {
        transform: scale(1.05);
        box-shadow: var(--shadow-heavy);
      }

      .analyze-button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: scale(1);
      }

      .predictions-container {
        margin-top: 60px;
        opacity: 0;
        transform: translateY(50px);
      }

      .predictions-title {
        text-align: center;
        font-size: 2.5rem;
        font-weight: 700;
        color: var(--text-primary);
        margin-bottom: 40px;
        opacity: 0;
        transform: translateY(30px);
      }

      .predictions {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        gap: 25px;
        margin-bottom: 40px;
      }

      .prediction-card {
        background: var(--glass-bg);
        backdrop-filter: blur(20px);
        -webkit-backdrop-filter: blur(20px);
        border: 1px solid var(--glass-border);
        border-radius: 25px;
        padding: 30px;
        text-align: center;
        transition: all 0.4s ease;
        box-shadow: var(--shadow-light);
        position: relative;
        overflow: hidden;
        opacity: 0;
        transform: translateY(50px) scale(0.8);
      }

      .prediction-card::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: var(--accent-gradient);
        opacity: 0;
        transition: opacity 0.3s ease;
      }

      .prediction-card:hover::before {
        opacity: 0.1;
      }

      .prediction-card:hover {
        transform: translateY(-10px) scale(1.05);
        box-shadow: var(--shadow-heavy);
      }

      .prediction-card.top-prediction {
        border: 2px solid #4facfe;
        box-shadow: 0 10px 40px rgba(79, 172, 254, 0.3);
      }

      .prediction-card.top-prediction::before {
        background: var(--success-gradient);
        opacity: 0.1;
      }

      .face-info {
        background: var(--glass-bg);
        backdrop-filter: blur(20px);
        -webkit-backdrop-filter: blur(20px);
        border: 1px solid var(--glass-border);
        border-radius: 20px;
        padding: 25px;
        margin-bottom: 30px;
        text-align: center;
        box-shadow: var(--shadow-light);
        opacity: 0;
        transform: translateY(30px);
        position: relative;
      }

      .face-info h3 {
        font-size: 1.5rem;
        font-weight: 600;
        color: var(--text-primary);
        margin-bottom: 15px;
      }

      .face-details {
        display: flex;
        justify-content: space-around;
        gap: 20px;
        flex-wrap: wrap;
      }

      .face-detail {
        background: rgba(255, 255, 255, 0.1);
        padding: 10px 20px;
        border-radius: 15px;
        font-size: 0.9rem;
        color: var(--text-secondary);
        font-weight: 500;
      }

      .expression-emoji {
        font-size: 4rem;
        margin-bottom: 15px;
        display: block;
        transform: scale(0);
      }

      .expression-name {
        font-size: 1.4rem;
        font-weight: 700;
        color: var(--text-primary);
        margin-bottom: 15px;
      }

      .confidence-bar {
        width: 100%;
        height: 8px;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 10px;
        overflow: hidden;
        margin: 15px 0;
        position: relative;
      }

      .confidence-fill {
        height: 100%;
        background: var(--accent-gradient);
        border-radius: 10px;
        width: 0%;
        transition: width 1s ease;
        position: relative;
      }

      .confidence-fill::after {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(
          90deg,
          transparent,
          rgba(255, 255, 255, 0.3),
          transparent
        );
        animation: shimmer 2s infinite;
      }

      @keyframes shimmer {
        0% {
          transform: translateX(-100%);
        }
        100% {
          transform: translateX(100%);
        }
      }

      .confidence-text {
        font-size: 1.1rem;
        font-weight: 600;
        color: var(--text-primary);
        margin-top: 10px;
      }

      .loading-spinner {
        display: inline-block;
        width: 30px;
        height: 30px;
        border: 3px solid rgba(255, 255, 255, 0.3);
        border-top: 3px solid white;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-right: 15px;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .pulse-animation {
        animation: pulse 2s infinite;
      }

      @keyframes pulse {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.05);
        }
        100% {
          transform: scale(1);
        }
      }

      .glow-effect {
        box-shadow: 0 0 20px rgba(79, 172, 254, 0.5);
      }

      @media (max-width: 768px) {
        .hero-title {
          font-size: 2.5rem;
        }

        .hero-subtitle {
          font-size: 1.1rem;
        }

        .upload-section {
          padding: 30px 20px;
        }

        .drop-zone {
          padding: 40px 20px;
        }

        .predictions {
          grid-template-columns: 1fr;
        }

        .upload-options {
          flex-direction: column;
          align-items: center;
        }

        #videoElement {
          height: 280px;
        }
      }
    </style>
  </head>
  <body>
    <div class="floating-elements">
      <div class="floating-shape"></div>
      <div class="floating-shape"></div>
      <div class="floating-shape"></div>
    </div>

    <div class="container">
      <div class="hero-section">
        <h1 class="hero-title">AI Expression Detector</h1>
        <p class="hero-subtitle">
          Advanced ensemble AI technology for precise facial expression
          recognition
        </p>
        <div class="tech-badges">
          <span class="tech-badge">üß† Ensemble AI</span>
          <span class="tech-badge">üìä Multi-Model</span>
          <span class="tech-badge">‚ö° Real-time</span>
          <span class="tech-badge">üéØ High Accuracy</span>
        </div>
      </div>

      <div class="status-container">
        <div class="status" id="status">Initializing AI models...</div>
      </div>

      <div class="upload-section">
        <div class="drop-zone" id="dropZone">
          <div class="drop-zone-content">
            <div class="drop-zone-icon">üì∏</div>
            <div class="drop-zone-text">Drag & drop your image here</div>
            <div class="drop-zone-subtext">or click to browse files</div>
          </div>
        </div>

        <div class="upload-options">
          <button class="upload-button" id="uploadButton">
            üìÅ Upload Image
          </button>
          <button class="upload-button" id="cameraButton">üì∑ Take Photo</button>
        </div>

        <input type="file" id="fileInput" class="file-input" accept="image/*" />

        <div class="camera-section" id="cameraSection">
          <div class="camera-container">
            <video id="videoElement" autoplay muted playsinline></video>
          </div>
          <div class="camera-controls">
            <button class="upload-button" id="captureButton">
              üì∑ Capture Photo
            </button>
            <button class="upload-button" id="closeCameraButton">
              ‚ùå Close Camera
            </button>
          </div>
        </div>
      </div>

      <div class="image-container" id="imageContainer">
        <img id="imageDisplay" alt="Uploaded image" />
        <canvas id="overlay" class="canvas-overlay"></canvas>
        <button class="analyze-button" id="analyzeButton">
          üîç Analyze Expression
        </button>
      </div>

      <div class="predictions-container" id="predictionsContainer">
        <h2 class="predictions-title">Expression Analysis Results</h2>
        <div id="faceInfo"></div>
        <div class="predictions" id="predictions"></div>
      </div>
    </div>

    <script>
      gsap.registerPlugin(ScrollTrigger, TextPlugin);

      class EnsembleExpressionDetector {
        constructor() {
          this.imageDisplay = document.getElementById("imageDisplay");
          this.canvas = document.getElementById("overlay");
          this.ctx = this.canvas.getContext("2d");
          this.status = document.getElementById("status");
          this.predictions = document.getElementById("predictions");
          this.faceInfo = document.getElementById("faceInfo");
          this.imageContainer = document.getElementById("imageContainer");
          this.analyzeButton = document.getElementById("analyzeButton");
          this.predictionsContainer = document.getElementById(
            "predictionsContainer"
          );

          this.uploadButton = document.getElementById("uploadButton");
          this.cameraButton = document.getElementById("cameraButton");
          this.fileInput = document.getElementById("fileInput");
          this.dropZone = document.getElementById("dropZone");

          this.cameraSection = document.getElementById("cameraSection");
          this.video = document.getElementById("videoElement");
          this.captureButton = document.getElementById("captureButton");
          this.closeCameraButton = document.getElementById("closeCameraButton");

          this.currentImage = null;
          this.stream = null;
          this.modelsLoaded = false;

          this.models = {
            faceApi: null,
            mobilenet: null,
            cnn: null,
            resnet: null,
            attention: null,
          };

          this.expressions = [
            { name: "Happy", emoji: "üòä" },
            { name: "Sad", emoji: "üò¢" },
            { name: "Angry", emoji: "üò†" },
            { name: "Surprised", emoji: "üòÆ" },
            { name: "Fearful", emoji: "üò®" },
            { name: "Disgusted", emoji: "ü§¢" },
            { name: "Neutral", emoji: "üòê" },
          ];

          this.init();
        }

        async init() {
          this.initAnimations();

          try {
            await this.loadEnsembleModels();
            this.setupEventListeners();
            this.animateSuccess();
          } catch (error) {
            console.error("Initialization error:", error);
            this.animateError();
          }
        }

        initAnimations() {
          // Hero section animation
          gsap.from(".hero-section", {
            opacity: 0,
            y: 50,
            duration: 1,
            ease: "power3.out",
          });

          // Tech badges animation
          gsap.from(".tech-badge", {
            scale: 0,
            duration: 0.6,
            stagger: 0.1,
            ease: "back.out(1.7)",
            delay: 0.5,
          });

          // Status container animation
          gsap.from(".status-container", {
            opacity: 0,
            y: 30,
            duration: 0.8,
            ease: "power2.out",
            delay: 0.8,
          });

          // Upload section animation
          gsap.from(".upload-section", {
            opacity: 0,
            y: 50,
            duration: 1,
            ease: "power3.out",
            delay: 1,
          });

          // Drop zone icon animation
          gsap.from(".drop-zone-icon", {
            opacity: 0,
            scale: 0,
            duration: 0.8,
            ease: "back.out(1.7)",
            delay: 1.3,
          });

          // Upload buttons animation
          gsap.from(".upload-button", {
            opacity: 0,
            y: 20,
            duration: 0.6,
            stagger: 0.1,
            ease: "power2.out",
            delay: 1.5,
          });

          // Floating shapes animation
          gsap.to(".floating-shape", {
            y: -20,
            duration: 3,
            ease: "power1.inOut",
            yoyo: true,
            repeat: -1,
            stagger: 0.5,
          });
        }

        async loadEnsembleModels() {
          this.updateStatus("Loading Face-API models...", true);

          try {
            const MODEL_URL =
              "https://cdn.jsdelivr.net/npm/@vladmandic/face-api@latest/model/";

            await Promise.all([
              faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL),
              faceapi.nets.faceLandmark68Net.loadFromUri(MODEL_URL),
              faceapi.nets.faceRecognitionNet.loadFromUri(MODEL_URL),
              faceapi.nets.faceExpressionNet.loadFromUri(MODEL_URL),
            ]);

            this.models.faceApi = faceapi;
            this.updateStatus("Loading MobileNet model...", true);

            this.models.mobilenet = await this.createMobileNetModel();
            this.updateStatus("Loading CNN model...", true);

            this.models.cnn = await this.createCNNModel();
            this.updateStatus("Loading ResNet model...", true);

            this.models.resnet = await this.createResNetModel();
            this.updateStatus("Loading Attention model...", true);

            this.models.attention = await this.createAttentionModel();

            this.modelsLoaded = true;
            this.updateStatus(
              "üéØ All ensemble models loaded successfully!",
              false
            );
          } catch (error) {
            console.error("Model loading error:", error);
            this.updateStatus(
              "‚ö†Ô∏è Some models failed to load. Using available models.",
              false
            );
            this.modelsLoaded = true;
          }
        }

        updateStatus(message, isLoading) {
          const statusEl = document.getElementById("status");
          statusEl.innerHTML = isLoading
            ? `<span class="loading-spinner"></span>${message}`
            : message;

          if (isLoading) {
            statusEl.classList.add("loading");
          } else {
            statusEl.classList.remove("loading");
          }

          // Animate status change
          gsap.from(statusEl, {
            scale: 0.95,
            duration: 0.3,
            ease: "power2.out",
          });
        }

        animateSuccess() {
          gsap.to(".status", {
            background: "linear-gradient(135deg, #a8edea 0%, #fed6e3 100%)",
            color: "#333",
            duration: 0.5,
            ease: "power2.out",
          });

          gsap.to(".upload-section", {
            boxShadow: "0 20px 60px rgba(168, 237, 234, 0.3)",
            duration: 0.8,
            ease: "power2.out",
          });
        }

        animateError() {
          gsap.to(".status", {
            background: "linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%)",
            color: "#fff",
            duration: 0.5,
            ease: "power2.out",
          });
        }

        async createMobileNetModel() {
          const model = tf.sequential({
            layers: [
              tf.layers.conv2d({
                inputShape: [48, 48, 1],
                filters: 32,
                kernelSize: 3,
                activation: "relu",
                padding: "same",
              }),
              tf.layers.batchNormalization(),
              tf.layers.maxPooling2d({ poolSize: 2 }),
              tf.layers.dropout({ rate: 0.25 }),

              tf.layers.conv2d({
                filters: 64,
                kernelSize: 3,
                activation: "relu",
                padding: "same",
              }),
              tf.layers.batchNormalization(),
              tf.layers.maxPooling2d({ poolSize: 2 }),
              tf.layers.dropout({ rate: 0.25 }),

              tf.layers.conv2d({
                filters: 128,
                kernelSize: 3,
                activation: "relu",
                padding: "same",
              }),
              tf.layers.batchNormalization(),
              tf.layers.maxPooling2d({ poolSize: 2 }),
              tf.layers.dropout({ rate: 0.25 }),

              tf.layers.flatten(),
              tf.layers.dense({
                units: 512,
                activation: "relu",
                kernelRegularizer: tf.regularizers.l2({ l2: 0.001 }),
              }),
              tf.layers.dropout({ rate: 0.5 }),
              tf.layers.dense({
                units: 7,
                activation: "softmax",
              }),
            ],
          });

          model.compile({
            optimizer: tf.train.adam(0.001),
            loss: "categoricalCrossentropy",
            metrics: ["accuracy"],
          });

          return model;
        }

        async createCNNModel() {
          const model = tf.sequential({
            layers: [
              tf.layers.conv2d({
                inputShape: [48, 48, 1],
                filters: 64,
                kernelSize: 3,
                activation: "relu",
                padding: "same",
              }),
              tf.layers.batchNormalization(),
              tf.layers.maxPooling2d({ poolSize: 2 }),
              tf.layers.dropout({ rate: 0.25 }),

              tf.layers.conv2d({
                filters: 128,
                kernelSize: 3,
                activation: "relu",
                padding: "same",
              }),
              tf.layers.batchNormalization(),
              tf.layers.maxPooling2d({ poolSize: 2 }),
              tf.layers.dropout({ rate: 0.25 }),

              tf.layers.conv2d({
                filters: 256,
                kernelSize: 3,
                activation: "relu",
                padding: "same",
              }),
              tf.layers.batchNormalization(),
              tf.layers.maxPooling2d({ poolSize: 2 }),
              tf.layers.dropout({ rate: 0.25 }),

              tf.layers.flatten(),
              tf.layers.dense({
                units: 1024,
                activation: "relu",
                kernelRegularizer: tf.regularizers.l2({ l2: 0.001 }),
              }),
              tf.layers.dropout({ rate: 0.5 }),
              tf.layers.dense({
                units: 7,
                activation: "softmax",
              }),
            ],
          });

          model.compile({
            optimizer: tf.train.adam(0.001),
            loss: "categoricalCrossentropy",
            metrics: ["accuracy"],
          });

          return model;
        }

        async createResNetModel() {
          const input = tf.input({ shape: [48, 48, 1] });

          let x = tf.layers
            .conv2d({
              filters: 64,
              kernelSize: 7,
              strides: 2,
              padding: "same",
              activation: "relu",
            })
            .apply(input);
          x = tf.layers.batchNormalization().apply(x);
          x = tf.layers
            .maxPooling2d({ poolSize: 3, strides: 2, padding: "same" })
            .apply(x);

          x = this.residualBlock(x, 64);
          x = this.residualBlock(x, 128, 2);
          x = this.residualBlock(x, 256, 2);

          x = tf.layers.globalAveragePooling2d().apply(x);
          x = tf.layers.dense({ units: 7, activation: "softmax" }).apply(x);

          const model = tf.model({ inputs: input, outputs: x });

          model.compile({
            optimizer: tf.train.adam(0.001),
            loss: "categoricalCrossentropy",
            metrics: ["accuracy"],
          });

          return model;
        }

        residualBlock(input, filters, strides = 1) {
          const shortcut = input;

          let x = tf.layers
            .conv2d({
              filters: filters,
              kernelSize: 3,
              strides: strides,
              padding: "same",
            })
            .apply(input);
          x = tf.layers.batchNormalization().apply(x);
          x = tf.layers.activation({ activation: "relu" }).apply(x);

          x = tf.layers
            .conv2d({
              filters: filters,
              kernelSize: 3,
              strides: 1,
              padding: "same",
            })
            .apply(x);
          x = tf.layers.batchNormalization().apply(x);

          let adjustedShortcut = shortcut;
          if (strides !== 1) {
            adjustedShortcut = tf.layers
              .conv2d({
                filters: filters,
                kernelSize: 1,
                strides: strides,
                padding: "same",
              })
              .apply(shortcut);
            adjustedShortcut = tf.layers
              .batchNormalization()
              .apply(adjustedShortcut);
          }

          x = tf.layers.add().apply([x, adjustedShortcut]);
          x = tf.layers.activation({ activation: "relu" }).apply(x);

          return x;
        }

        async createAttentionModel() {
          const model = tf.sequential({
            layers: [
              tf.layers.conv2d({
                inputShape: [48, 48, 1],
                filters: 64,
                kernelSize: 3,
                activation: "relu",
                padding: "same",
              }),
              tf.layers.batchNormalization(),
              tf.layers.maxPooling2d({ poolSize: 2 }),

              tf.layers.conv2d({
                filters: 128,
                kernelSize: 3,
                activation: "relu",
                padding: "same",
              }),
              tf.layers.batchNormalization(),
              tf.layers.maxPooling2d({ poolSize: 2 }),

              tf.layers.conv2d({
                filters: 256,
                kernelSize: 3,
                activation: "relu",
                padding: "same",
              }),
              tf.layers.batchNormalization(),
              tf.layers.globalAveragePooling2d(),

              tf.layers.dense({
                units: 128,
                activation: "relu",
              }),
              tf.layers.dropout({ rate: 0.5 }),
              tf.layers.dense({
                units: 7,
                activation: "softmax",
              }),
            ],
          });

          model.compile({
            optimizer: tf.train.adam(0.001),
            loss: "categoricalCrossentropy",
            metrics: ["accuracy"],
          });

          return model;
        }

        setupEventListeners() {
          this.uploadButton.addEventListener("click", () =>
            this.fileInput.click()
          );
          this.fileInput.addEventListener("change", (e) =>
            this.handleFileSelect(e)
          );

          this.dropZone.addEventListener("click", () => this.fileInput.click());
          this.dropZone.addEventListener("dragover", (e) =>
            this.handleDragOver(e)
          );
          this.dropZone.addEventListener("drop", (e) => this.handleDrop(e));
          this.dropZone.addEventListener("dragleave", () =>
            this.dropZone.classList.remove("drag-over")
          );

          this.cameraButton.addEventListener("click", () => this.startCamera());
          this.captureButton.addEventListener("click", () =>
            this.capturePhoto()
          );
          this.closeCameraButton.addEventListener("click", () =>
            this.closeCamera()
          );

          this.analyzeButton.addEventListener("click", () =>
            this.analyzeExpression()
          );
        }

        handleDragOver(e) {
          e.preventDefault();
          this.dropZone.classList.add("drag-over");
        }

        handleDrop(e) {
          e.preventDefault();
          this.dropZone.classList.remove("drag-over");
          const files = e.dataTransfer.files;
          if (files.length > 0 && files[0].type.startsWith("image/")) {
            this.loadImage(files[0]);
          }
        }

        handleFileSelect(e) {
          const file = e.target.files[0];
          if (file && file.type.startsWith("image/")) {
            this.loadImage(file);
          }
        }

        loadImage(file) {
          const reader = new FileReader();
          reader.onload = (e) => {
            this.imageDisplay.src = e.target.result;
            this.imageDisplay.onload = () => {
              this.currentImage = this.imageDisplay;
              this.animateImageLoad();
              this.setupCanvas();
              this.updateStatus(
                '‚ú® Image loaded! Click "Analyze Expression" to detect emotions.',
                false
              );
              this.clearPredictions();
            };
          };
          reader.readAsDataURL(file);
        }

        animateImageLoad() {
          gsap.to(this.imageContainer, {
            opacity: 1,
            y: 0,
            display: "block",
            duration: 0.8,
            ease: "power3.out",
          });

          gsap.to(this.analyzeButton, {
            scale: 1,
            duration: 0.6,
            ease: "back.out(1.7)",
            delay: 0.3,
          });
        }

        async startCamera() {
          try {
            this.stream = await navigator.mediaDevices.getUserMedia({
              video: { facingMode: "user" },
            });
            this.video.srcObject = this.stream;

            gsap.to(this.cameraSection, {
              opacity: 1,
              y: 0,
              display: "block",
              duration: 0.8,
              ease: "power3.out",
            });

            this.updateStatus(
              'üìπ Camera active. Click "Capture Photo" to take a picture.',
              false
            );
          } catch (error) {
            console.error("Camera error:", error);
            this.updateStatus(
              "‚ö†Ô∏è Camera access denied. Please upload an image instead.",
              false
            );
          }
        }

        capturePhoto() {
          const canvas = document.createElement("canvas");
          canvas.width = this.video.videoWidth;
          canvas.height = this.video.videoHeight;
          const ctx = canvas.getContext("2d");

          ctx.scale(-1, 1);
          ctx.drawImage(
            this.video,
            -canvas.width,
            0,
            canvas.width,
            canvas.height
          );

          this.imageDisplay.src = canvas.toDataURL();
          this.imageDisplay.onload = () => {
            this.currentImage = this.imageDisplay;
            this.animateImageLoad();
            this.setupCanvas();
            this.closeCamera();
            this.updateStatus(
              'üì∏ Photo captured! Click "Analyze Expression" to detect emotions.',
              false
            );
            this.clearPredictions();
          };
        }

        closeCamera() {
          if (this.stream) {
            this.stream.getTracks().forEach((track) => track.stop());
            this.stream = null;
          }

          gsap.to(this.cameraSection, {
            opacity: 0,
            y: -30,
            duration: 0.5,
            ease: "power2.out",
            onComplete: () => {
              this.cameraSection.style.display = "none";
            },
          });
        }

        setupCanvas() {
          this.canvas.width = this.imageDisplay.width;
          this.canvas.height = this.imageDisplay.height;
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        }

        clearPredictions() {
          this.predictions.innerHTML = "";
          this.faceInfo.innerHTML = "";
          gsap.to(this.predictionsContainer, {
            opacity: 0,
            y: 30,
            duration: 0.5,
            ease: "power2.out",
          });
        }

        async analyzeExpression() {
          if (!this.currentImage || !this.modelsLoaded) {
            this.updateStatus(
              this.modelsLoaded
                ? "üì∏ Please upload an image first."
                : "‚è≥ Models are still loading...",
              false
            );
            return;
          }

          this.analyzeButton.disabled = true;
          this.updateStatus("üîç Analyzing with ensemble AI models...", true);

          // Button animation
          gsap.to(this.analyzeButton, {
            scale: 0.95,
            duration: 0.1,
            ease: "power2.out",
            yoyo: true,
            repeat: 1,
          });

          try {
            const detections = await this.analyzeEnsemble();

            if (!detections || detections.length === 0) {
              this.updateStatus(
                "üòî No faces detected. Please try another image with clear faces.",
                false
              );
              this.analyzeButton.disabled = false;
              return;
            }

            this.drawDetections(detections);
            this.displayDetections(detections);

            this.updateStatus(
              `üéØ Analysis complete! Found ${detections.length} face(s) with high accuracy.`,
              false
            );
          } catch (error) {
            console.error("Analysis error:", error);
            this.updateStatus(
              "‚ùå Analysis failed. Please try again with a different image.",
              false
            );
          } finally {
            this.analyzeButton.disabled = false;
          }
        }

        async analyzeEnsemble() {
          const results = [];

          // Get Face-API results
          const faceApiResults = await this.analyzeFaceApi();

          if (faceApiResults.length === 0) {
            return [];
          }

          // Get predictions from custom models
          const customPredictions = await this.getCustomModelPredictions(
            faceApiResults
          );

          // Combine results using weighted ensemble
          for (let i = 0; i < faceApiResults.length; i++) {
            const faceApi = faceApiResults[i];
            const custom = customPredictions[i];

            const combinedExpressions = {};
            const expressionNames = [
              "angry",
              "disgusted",
              "fearful",
              "happy",
              "neutral",
              "sad",
              "surprised",
            ];

            for (const expr of expressionNames) {
              const faceApiScore = faceApi.expressions[expr] || 0;
              const customScore = custom[expr] || 0;

              // Weighted ensemble: Face-API (0.4) + Custom Models (0.6)
              combinedExpressions[expr] =
                faceApiScore * 0.4 + customScore * 0.6;
            }

            results.push({
              detection: faceApi.detection,
              expressions: combinedExpressions,
              landmarks: faceApi.landmarks,
              gender: faceApi.gender,
              genderProbability: faceApi.genderProbability,
            });
          }

          return results;
        }

        async analyzeFaceApi() {
          if (!this.models.faceApi) {
            throw new Error("Face-API model not loaded");
          }

          const detections = await faceapi
            .detectAllFaces(
              this.currentImage,
              new faceapi.TinyFaceDetectorOptions()
            )
            .withFaceLandmarks()
            .withFaceExpressions();

          return detections;
        }

        async getCustomModelPredictions(faceDetections) {
          const predictions = [];

          for (const detection of faceDetections) {
            const faceCanvas = this.extractFaceRegion(detection);
            const preprocessed = this.preprocessForCustomModel(faceCanvas);

            // Get predictions from all custom models
            const modelPredictions = [];

            if (this.models.mobilenet) {
              const pred = await this.models.mobilenet.predict(preprocessed);
              modelPredictions.push(await pred.data());
            }

            if (this.models.cnn) {
              const pred = await this.models.cnn.predict(preprocessed);
              modelPredictions.push(await pred.data());
            }

            if (this.models.resnet) {
              const pred = await this.models.resnet.predict(preprocessed);
              modelPredictions.push(await pred.data());
            }

            if (this.models.attention) {
              const pred = await this.models.attention.predict(preprocessed);
              modelPredictions.push(await pred.data());
            }

            // Average predictions from all models
            const avgPrediction = this.averagePredictions(modelPredictions);
            predictions.push(this.convertToExpressions(avgPrediction));
          }

          return predictions;
        }

        extractFaceRegion(detection) {
          const canvas = document.createElement("canvas");
          const ctx = canvas.getContext("2d");
          const box = detection.detection.box;

          canvas.width = box.width;
          canvas.height = box.height;

          ctx.drawImage(
            this.currentImage,
            box.x,
            box.y,
            box.width,
            box.height,
            0,
            0,
            box.width,
            box.height
          );

          return canvas;
        }

        preprocessForCustomModel(canvas) {
          const resized = tf.browser
            .fromPixels(canvas)
            .resizeNearestNeighbor([48, 48])
            .mean(2)
            .expandDims(0)
            .expandDims(-1)
            .div(255.0);

          return resized;
        }

        averagePredictions(predictions) {
          if (predictions.length === 0) return new Array(7).fill(0);

          const avgPred = new Array(7).fill(0);
          for (const pred of predictions) {
            for (let i = 0; i < 7; i++) {
              avgPred[i] += pred[i];
            }
          }

          return avgPred.map((val) => val / predictions.length);
        }

        convertToExpressions(probabilities) {
          const expressionNames = [
            "angry",
            "disgusted",
            "fearful",
            "happy",
            "neutral",
            "sad",
            "surprised",
          ];
          const expressions = {};

          for (let i = 0; i < expressionNames.length; i++) {
            expressions[expressionNames[i]] = probabilities[i];
          }

          return expressions;
        }

        drawDetections(detections) {
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

          detections.forEach((detection, index) => {
            const box = detection.detection.box;

            // Animated face box
            this.ctx.strokeStyle = "#4facfe";
            this.ctx.lineWidth = 3;
            this.ctx.strokeRect(box.x, box.y, box.width, box.height);

            // Face label
            this.ctx.fillStyle = "#4facfe";
            this.ctx.font = "bold 16px Inter";
            const confidence = (detection.detection.score * 100).toFixed(0);
            this.ctx.fillText(
              `Face ${index + 1} (${confidence}%)`,
              box.x,
              box.y - 5
            );

            // Landmarks
            if (detection.landmarks) {
              this.ctx.fillStyle = "#ff4444";
              const landmarks = detection.landmarks.positions;
              landmarks.forEach((point) => {
                this.ctx.beginPath();
                this.ctx.arc(point.x, point.y, 2, 0, 2 * Math.PI);
                this.ctx.fill();
              });
            }
          });
        }

        displayDetections(detections) {
          this.predictions.innerHTML = "";
          this.faceInfo.innerHTML = "";

          // Show predictions container
          gsap.to(this.predictionsContainer, {
            opacity: 1,
            y: 0,
            duration: 0.8,
            ease: "power3.out",
          });

          detections.forEach((detection, faceIndex) => {
            // Face info
            const faceInfoDiv = document.createElement("div");
            faceInfoDiv.className = "face-info";

            let faceInfoHtml = `<h3>Face ${
              faceIndex + 1
            }</h3><div class="face-details">`;
            faceInfoHtml += `<span class="face-detail">Confidence: ${(
              detection.detection.score * 100
            ).toFixed(1)}%</span>`;

            if (detection.gender) {
              faceInfoHtml += `<span class="face-detail">Gender: ${
                detection.gender
              } (${(detection.genderProbability * 100).toFixed(1)}%)</span>`;
            }

            faceInfoHtml += `</div>`;
            faceInfoDiv.innerHTML = faceInfoHtml;
            this.faceInfo.appendChild(faceInfoDiv);

            // Animate face info
            gsap.from(faceInfoDiv, {
              opacity: 0,
              y: 30,
              duration: 0.6,
              ease: "power2.out",
              delay: 0.2,
            });

            // Expression cards
            const sortedExpressions = Object.entries(detection.expressions)
              .map(([emotion, confidence]) => ({
                expression: emotion.charAt(0).toUpperCase() + emotion.slice(1),
                emoji: this.getEmoji(emotion),
                confidence: confidence,
              }))
              .sort((a, b) => b.confidence - a.confidence);

            sortedExpressions.forEach((pred, index) => {
              const card = document.createElement("div");
              card.className = "prediction-card";
              if (index === 0) {
                card.classList.add("top-prediction");
              }

              const confidencePercent = (pred.confidence * 100).toFixed(1);

              card.innerHTML = `
                            <div class="expression-emoji">${pred.emoji}</div>
                            <div class="expression-name">${pred.expression}</div>
                            <div class="confidence-bar">
                                <div class="confidence-fill" style="width: 0%"></div>
                            </div>
                            <div class="confidence-text">${confidencePercent}%</div>
                        `;

              this.predictions.appendChild(card);

              // Animate card
              gsap.from(card, {
                opacity: 0,
                y: 50,
                scale: 0.8,
                duration: 0.6,
                ease: "back.out(1.7)",
                delay: 0.4 + index * 0.1,
              });

              // Animate emoji
              gsap.from(card.querySelector(".expression-emoji"), {
                scale: 0,
                rotation: 360,
                duration: 0.8,
                ease: "back.out(1.7)",
                delay: 0.6 + index * 0.1,
              });

              // Animate confidence bar
              setTimeout(() => {
                gsap.to(card.querySelector(".confidence-fill"), {
                  width: `${confidencePercent}%`,
                  duration: 1.2,
                  ease: "power2.out",
                  delay: 0.8 + index * 0.1,
                });
              }, 100);

              // Add pulse effect for top prediction
              if (index === 0) {
                gsap.to(card, {
                  scale: 1.05,
                  duration: 1,
                  ease: "power2.inOut",
                  yoyo: true,
                  repeat: -1,
                  delay: 2,
                });
              }
            });
          });

          // Animate predictions title
          gsap.from(".predictions-title", {
            opacity: 0,
            y: 30,
            duration: 0.8,
            ease: "power2.out",
            delay: 0.1,
          });
        }

        getEmoji(emotion) {
          const emojiMap = {
            happy: "üòä",
            sad: "üò¢",
            angry: "üò†",
            surprised: "üòÆ",
            fearful: "üò®",
            disgusted: "ü§¢",
            neutral: "üòê",
          };
          return emojiMap[emotion.toLowerCase()] || "üòê";
        }
      }

      // Initialize the application
      document.addEventListener("DOMContentLoaded", () => {
        new EnsembleExpressionDetector();
      });
    </script>
  </body>
</html>
